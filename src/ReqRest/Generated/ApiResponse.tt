<#
    // Recommendation:
    // Don't edit this file in Visual Studio. Download VS Code and this extension:
    // https://marketplace.visualstudio.com/items?itemName=zbecknell.t4-support
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
const int MinParametersToGenerate = 0;
const int MaxParametersToGenerate = 8;

// Generates the string for a type parameter, e.g. "T1" or "T2".
// Empty string for 0, i.e. no type parameter.
string GetTParam(int index) =>
	index == 0 ? "" : $"T{index}";

// Generates a list of type parameters until the index, e.g. ["T1", "T2", "T3"].
// Empty list for 0, i.e. no type parameter.
string[] GetTParamList(int to) =>
	Enumerable
		.Range(1, to)
		.Select(i => GetTParam(i))
		.Where(s => !string.IsNullOrEmpty(s))
		.ToArray();

// Generates a string representing a list of type parameters until the index, e.g. "T1, T2, T3".
// Empty string for 0, i.e. no type parameter.
string GetTParamListString(int to) =>
	string.Join(", ", GetTParamList(to));

// Generates a type parameter declaration of parameters until the index, e.g. "<T1, T2, T3>".
// Empty string for 0, i.e. no type parameter.
string GetTParamDeclaration(int to) =>
	to == 0 ? "" : $"<{GetTParamListString(to)}>";

// Generates a type parameter declaration for XML comments of parameters until the index, e.g. "{T1, T2, T3}".
// Empty string for 0, i.e. no type parameter.
string GetTParamXmlDeclaration(int to) =>
	to == 0 ? "" : $"{{{GetTParamListString(to)}}}";

// Are type parameters generated for this index?
bool HasTypeParameter(int index) =>
	index != 0;
#>
// This code has been auto-generated by the associated .tt file.
// Any changes made to in this file will be lost when the file is regenerated.

namespace ReqRest
{
    using System;
    using System.Collections.Generic;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;
    using NCommons.Monads;
    using ReqRest.Serializers;
<#  for (var i = MinParametersToGenerate; i <= MaxParametersToGenerate; i++) {
        var T = GetTParam(i);
        var TList = GetTParamList(i);
        var TListString = GetTParamListString(i);
        var TDeclaration = GetTParamDeclaration(i);
        var TXmlDeclaration = GetTParamXmlDeclaration(i);
        var hasTParam = HasTypeParameter(i); #>

    /// <summary>
    ///     Encapsulates information which were returned by a RESTful HTTP API after making
    ///     a request to it.
<#      if (hasTParam) { #>
    ///     
    ///     This class declares that its HTTP content can potentially be deserialized to one of the
    ///     generic types, as long as the response has the appropriate HTTP status code.
<#      } #>
    /// </summary>
<#      foreach (var Tx in TList) { #>
    /// <typeparam name="<#= Tx #>">A type which may be deserialized from the response's HTTP content.</typeparam>
<#      } #>
    public sealed class ApiResponse<#= TDeclaration #> : ApiResponseBase
    {

        /// <summary>
        ///     Initializes a new <see cref="ApiResponse<#= TXmlDeclaration #>"/> instance with the specified values.
        /// </summary>
        /// <param name="httpResponseMessage">
        ///     The <see cref="HttpResponseMessage"/> which was the underlying
        ///     result returned by an <see cref="HttpClient"/> after making the associated request.
        ///     If <see langword="null"/>, a new instance is created instead.
        /// </param>
        /// <param name="possibleResponseTypes">
        ///     A set of elements that declare which .NET types may have been returned by the
        ///     HTTP API in this response.
        ///     If <see langword="null"/>, an empty set is used instead.
        /// </param>
        internal ApiResponse(
            HttpResponseMessage? httpResponseMessage,
            IEnumerable<ResponseTypeDescriptor>? possibleResponseTypes)
            : base(httpResponseMessage, possibleResponseTypes) { }

<#      if (hasTParam) { #>
        /// <summary>
        ///     Deserializes the HTTP content and returns the deserialized resource.
        /// </summary>
        /// <param name="cancellationToken">
        ///     A cancellation token which can be used to cancel the operation.
        /// </param>
        /// <returns>
        ///     The deserialized resource represented through a <see cref="Variant<#= TXmlDeclaration #>"/>
        ///     which holds a value that matches the response type declared for the response's HTTP status code.
        ///     This variant is empty if the response's HTTP status code doesn't match any declared one.
        /// </returns>
        /// <exception cref="HttpContentSerializationException">
        ///     There was a resource to deserialize, but the underlying <see cref="IHttpContentDeserializer"/>
        ///     threw an exception while deserializing the resource.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        ///     <see cref="ApiResponseBase.GetCurrentResponseTypeDescriptor"/> returned <see langword="null"/>.
        ///     
        ///     --or--
        ///     
        ///     The <see cref="ResponseTypeDescriptor.HttpContentDeserializerProvider"/> of the 
        ///     <see cref="ResponseTypeDescriptor"/> returned by 
        ///     <see cref="ApiResponseBase.GetCurrentResponseTypeDescriptor"/> returned <see langword="null"/>.
        /// </exception>
        /// <exception cref="TaskCanceledException">
        ///     The operation was canceled via the <paramref name="cancellationToken"/>.
        /// </exception>
        public async Task<Variant<#= TDeclaration #>> DeserializeResourceAsync(CancellationToken cancellationToken = default)
        {
<#          foreach (var Tx in TList) { #>
            if (CanDeserializeResource<<#= Tx #>>())
            {
                return await DeserializeResourceAsync<<#= Tx #>>(cancellationToken).ConfigureAwait(false);
            }
<#          } #>
            return new Variant<#= TDeclaration #>();
        }
<#      } #>

    }
<# } #>

}
