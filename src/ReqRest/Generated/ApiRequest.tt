<#
    // Recommendation:
    // Don't edit this file in Visual Studio. Download VS Code and this extension:
    // https://marketplace.visualstudio.com/items?itemName=zbecknell.t4-support
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
const int MinParametersToGenerate = 0;
const int MaxParametersToGenerate = 8;

// Generates the string for a type parameter, e.g. "T1" or "T2".
// Empty string for 0, i.e. no type parameter.
string GetTParam(int index) =>
	index == 0 ? "" : $"T{index}";

// Generates a list of type parameters until the index, e.g. ["T1", "T2", "T3"].
// Empty list for 0, i.e. no type parameter.
string[] GetTParamList(int to) =>
	Enumerable
		.Range(1, to)
		.Select(i => GetTParam(i))
		.Where(s => !string.IsNullOrEmpty(s))
		.ToArray();

// Generates a string representing a list of type parameters until the index, e.g. "T1, T2, T3".
// Empty string for 0, i.e. no type parameter.
string GetTParamListString(int to) =>
	string.Join(", ", GetTParamList(to));

// Generates a type parameter declaration of parameters until the index, e.g. "<T1, T2, T3>".
// Empty string for 0, i.e. no type parameter.
string GetTParamDeclaration(int to) =>
	to == 0 ? "" : $"<{GetTParamListString(to)}>";

// Generates a type parameter declaration for XML comments of parameters until the index, e.g. "{T1, T2, T3}".
// Empty string for 0, i.e. no type parameter.
string GetTParamXmlDeclaration(int to) =>
	to == 0 ? "" : $"{{{GetTParamListString(to)}}}";

// Are type parameters generated for this index?
bool HasTypeParameter(int index) =>
	index != 0;
#>
// This code has been auto-generated by the associated .tt file.
// Any changes made to in this file will be lost when the file is regenerated.

namespace ReqRest
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;
    using NCommons.Monads;
    using ReqRest.Http;
    using ReqRest.Internal.Serializers;
    using ReqRest.Serializers;
<#  for (var i = MinParametersToGenerate; i <= MaxParametersToGenerate; i++) {
        var T = GetTParam(i);
        var TList = GetTParamList(i);
        var TListString = GetTParamListString(i);
        var TDeclaration = GetTParamDeclaration(i);
        var TXmlDeclaration = GetTParamXmlDeclaration(i);
        var TNext = GetTParam(i + 1);
        var TNextDeclaration = GetTParamDeclaration(i + 1);
        var TPreviousDeclaration = i > 0 ? GetTParamDeclaration(i - 1) : "";
        var hasTParam = HasTypeParameter(i);
        var isLastT = i == MaxParametersToGenerate;
        
        string Upgrade(string newParam) =>
            string.IsNullOrEmpty(TListString)
                ? newParam 
                : $"{TListString}, {newParam}";
        #>

    /// <summary>
    ///     Encapsulates information for building and making a request to a RESTful HTTP API.
<#      if (hasTParam) { #>
    ///     
    ///     The HTTP content of a response to this request can potentially be deserialized to one of the
    ///     generic types, as long as it has the appropriate HTTP status code.
<#      } #>
    /// </summary>
<#      foreach (var Tx in TList) { #>
    /// <typeparam name="<#= Tx #>">A type which may be returned by a response following this request.</typeparam>
<#      } #>
    public sealed class ApiRequest<#= TDeclaration #> : ApiRequestBase
    {

<#      if (hasTParam) { #>
        /// <summary>
        ///     Initializes a new instance of the <see cref="ApiRequest<#= TXmlDeclaration #>"/> class which
        ///     upgrades a previous request in an upgrade chain.
        /// </summary>
        /// <param name="request">The request to be upgraded and wrapped.</param>
        /// <exception cref="ArgumentNullException">
        ///     * <paramref name="request"/>
        /// </exception>
        internal ApiRequest(ApiRequest<#= TPreviousDeclaration #> request)
            : base(request ?? throw new ArgumentNullException(nameof(request))) { }
<#      } else { #>
        /// <summary>
        ///     Initializes a new <see cref="ApiRequest"/> instance with the specified
        ///     initial property values.
        /// </summary>
        /// <param name="httpClientProvider">
        ///     A function which returns an <see cref="HttpClient"/> instance
        ///     which will ultimately be used to send the <see cref="HttpRequestMessage"/> for
        ///     executing the API request.
        /// </param>
        /// <param name="httpRequestMessage">
        ///     The request from which the builder starts building.
        ///     If <see langword="null"/>, a new instance is created instead.
        /// </param>
        /// <exception cref="ArgumentNullException">
        ///     * <paramref name="httpClientProvider"/>
        /// </exception>
        public ApiRequest(Func<HttpClient> httpClientProvider, HttpRequestMessage? httpRequestMessage = null)
            : base(httpClientProvider, httpRequestMessage) { }
<#      } #>

<#      if (!isLastT) { #>
        /// <summary>
        ///     Declares that the response to this request may have an empty HTTP content when
        ///     receiving a response with status code <c>204 No Content</c>.
        /// </summary>
        /// <returns>
        ///     An <see cref="ApiRequestBase"/>, upgraded with the <see cref="NoContent"/> type.
        /// </returns>
        public ApiRequest<<#= Upgrade("NoContent") #>> ReceiveNoContent() =>
            ReceiveNoContent(StatusCode.NoContent);

        /// <inheritdoc cref="ReceiveNoContent(IEnumerable{StatusCodeRange})"/>
        public ApiRequest<<#= Upgrade("NoContent") #>> ReceiveNoContent(params StatusCodeRange[] forStatusCodes) =>
            ReceiveNoContent((IEnumerable<StatusCodeRange>)forStatusCodes);

        /// <summary>
        ///     Declares that the response to this request may have an empty HTTP content, represented
        ///     through the <see cref="NoContent"/> type.
        /// </summary>
        /// <param name="forStatusCodes">
        ///     A set of status codes for which no content is received.
        /// </param>
        /// <returns>
        ///     An <see cref="ApiRequestBase"/>, upgraded with the <see cref="NoContent"/> type.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        ///     * <paramref name="forStatusCodes"/>
        /// </exception>
        /// <exception cref="ArgumentException">
        ///     <paramref name="forStatusCodes"/> is empty.
        /// </exception>
        public ApiRequest<<#= Upgrade("NoContent") #>> ReceiveNoContent(IEnumerable<StatusCodeRange> forStatusCodes) =>
            Receive<NoContent>().Build(NoContentSerializer.DefaultFactory, forStatusCodes);

        /// <inheritdoc cref="ReceiveByteArray(IEnumerable{StatusCodeRange})"/>
        public ApiRequest<<#= Upgrade("byte[]") #>> ReceiveByteArray(params StatusCodeRange[] forStatusCodes) =>
            ReceiveByteArray((IEnumerable<StatusCodeRange>)forStatusCodes);

        /// <summary>
        ///     Declares that the response to this request may have an HTTP content which can be
        ///     read as a <see cref="byte"/> array.
        /// </summary>
        /// <param name="forStatusCodes">
        ///     A set of status codes for which the HTTP content may be read as a <see cref="byte"/> array.
        /// </param>
        /// <returns>
        ///     An <see cref="ApiRequestBase"/>, upgraded with the <see cref="byte"/> array type.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        ///     * <paramref name="forStatusCodes"/>
        /// </exception>
        /// <exception cref="ArgumentException">
        ///     <paramref name="forStatusCodes"/> is empty.
        /// </exception>
        public ApiRequest<<#= Upgrade("byte[]") #>> ReceiveByteArray(IEnumerable<StatusCodeRange> forStatusCodes) =>
            Receive<byte[]>().Build(ByteArraySerializer.DefaultFactory, forStatusCodes);

        /// <inheritdoc cref="ReceiveString(IEnumerable{StatusCodeRange})"/>
        public ApiRequest<<#= Upgrade("string") #>> ReceiveString(params StatusCodeRange[] forStatusCodes) =>
            ReceiveString((IEnumerable<StatusCodeRange>)forStatusCodes);

        /// <summary>
        ///     Declares that the response to this request may have an HTTP content which can be
        ///     read as a raw string.
        /// </summary>
        /// <param name="forStatusCodes">
        ///     A set of status codes for which the HTTP content may be read as a raw string.
        /// </param>
        /// <returns>
        ///     An <see cref="ApiRequestBase"/>, upgraded with the <see cref="string"/> type.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        ///     * <paramref name="forStatusCodes"/>
        /// </exception>
        /// <exception cref="ArgumentException">
        ///     <paramref name="forStatusCodes"/> is empty.
        /// </exception>
        public ApiRequest<<#= Upgrade("string") #>> ReceiveString(IEnumerable<StatusCodeRange> forStatusCodes) =>
            Receive<string>().Build(StringSerializer.DefaultFactory, forStatusCodes);

        /// <summary>
        ///     Declares that the response to this request may have a content of type <typeparamref name="<#= TNext #>"/>.
        ///     This returns a builder instance which requires you to specify additional information about
        ///     the possible response (for example, for which status codes the type is a possible result).
        /// </summary>
        /// <typeparam name="<#= TNext #>">
        ///     The .NET type which may be returned by the response following this request.
        /// </typeparam>
        /// <returns>
        ///     An <see cref="ResponseTypeInfoBuilder{TRequest}"/> instance which must be used
        ///     to specify additional information about the possible response.
        /// </returns>
        public ResponseTypeInfoBuilder<ApiRequest<#= TNextDeclaration #>> Receive<<#= TNext #>>() =>
            new ResponseTypeInfoBuilder<ApiRequest<#= TNextDeclaration #>>(
                new ApiRequest<#= TNextDeclaration #>(this), typeof(<#= TNext #>));
<#      } #>

        /// <summary>
        ///     Sends the request and returns the resulting HTTP response without serializing its HTTP content.
        /// </summary>
        /// <param name="completionOption">
        ///     Defines when the operation should complete (as soon as a response is
        ///     available or after reading the whole response content).
        /// </param>
        /// <param name="cancellationToken">
        ///     A cancellation token which can be used to cancel the operation.
        /// </param>
        /// <returns>The response to the request.</returns>
        /// <exception cref="TaskCanceledException">
        ///     The operation was canceled via the <paramref name="cancellationToken"/>.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        ///     The <see cref="ApiRequestBase.HttpClientProvider"/> returned <see langword="null"/>.
        /// </exception>
        /// <remarks>
        ///     This method only returns the HTTP response itself and does not perform any deserialization logic.
<#      if (hasTParam) { #>
        ///     To access the underlying resource, use the <see cref="ApiResponse<#= TXmlDeclaration #>.DeserializeResourceAsync"/>
        ///     method of the response.
        ///     
        ///     Consider using the <see cref="FetchAsync(HttpCompletionOption, CancellationToken)"/> method if you
        ///     are interested in both the response and the underlying resource.
<#      } #>
        ///     
        ///     This method uses the <see cref="ApiRequestBase.HttpClientProvider"/> function for retrieving an
        ///     <see cref="HttpClient"/> with which the request will be sent.
        /// </remarks>
        /// <example>
        ///     <code>
        ///     var response = await request.FetchResponseAsync();
        ///     var resource = await response.DeserializeResourceAsync();
        ///     
        ///     Console.WriteLine($"Received status {response.StatusCode}");
        ///     Console.WriteLine($"Received a resource of type {resource.Value?.GetType()}");
        ///     </code>
        /// </example>
<#      if (hasTParam) { #>
        /// <seealso cref="FetchAsync(HttpCompletionOption, CancellationToken)"/>
        /// <seealso cref="FetchResourceAsync(HttpCompletionOption, CancellationToken)"/>
<#      } #>
        [DebuggerStepThrough]
        public async Task<ApiResponse<#= TDeclaration #>> FetchResponseAsync(
            HttpCompletionOption completionOption = HttpCompletionOption.ResponseContentRead,
            CancellationToken cancellationToken = default)
        {
            var res = await FetchHttpResponseAsync(completionOption, cancellationToken).ConfigureAwait(false);
            return new ApiResponse<#= TDeclaration #>(res, PossibleResponseTypes);
        }

<#      if (hasTParam) { #>
        /// <summary>
        ///     Sends the request, deserializes the HTTP content of the resulting HTTP response and
        ///     returns both the response and the deserialized resource.
        /// </summary>
        /// <param name="completionOption">
        ///     Defines when the operation should complete (as soon as a response is
        ///     available or after reading the whole response content).
        /// </param>
        /// <param name="cancellationToken">
        ///     A cancellation token which can be used to cancel the operation.
        /// </param>
        /// <returns>
        ///     A tuple which stores the response to the request and the resource which was deserialized
        ///     from the response's HTTP content.
        ///     
        ///     The resource is represented through a <see cref="Variant<#= TXmlDeclaration #>"/>
        ///     which holds a value that matches the response type declared for the response's HTTP status code.
        ///     This variant is empty if the response's HTTP status code doesn't match any declared one.    
        /// </returns>
        /// <exception cref="TaskCanceledException">
        ///     The operation was canceled via the <paramref name="cancellationToken"/>.
        /// </exception>
        /// <exception cref="HttpContentSerializationException">
        ///     There was a resource to deserialize, but the underlying <see cref="IHttpContentDeserializer"/>
        ///     threw an exception while deserializing the resource.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        ///     The <see cref="ApiRequestBase.HttpClientProvider"/> returned <see langword="null"/>.
        /// </exception>
        /// <remarks>
        ///     This method is designed for developer convenience and simply combines calling
        ///     <see cref="FetchResponseAsync(HttpCompletionOption, CancellationToken)"/> and
        ///     deserializing the resource afterwards.
        ///     
        ///     Be aware that this method may throw an <see cref="HttpContentSerializationException"/>,
        ///     because it runs the code of an arbitrary <see cref="IHttpContentDeserializer"/>.
        ///     
        ///     This method uses the <see cref="ApiRequestBase.HttpClientProvider"/> function for retrieving an
        ///     <see cref="HttpClient"/> with which the request will be sent.
        ///     
        ///     See the example for how to ideally use this method.
        /// </remarks>
        /// <seealso cref="FetchResponseAsync(HttpCompletionOption, CancellationToken)"/>
        /// <seealso cref="FetchResourceAsync(HttpCompletionOption, CancellationToken)"/>
        /// <example>
        ///     <code>
        ///     var (response, resource) = await request.FetchAsync();
        ///     
        ///     // Note: The above is equivalent to calling these two lines manually:
        ///     var response = await request.FetchResponseAsync();
        ///     var resource = await response.DeserializeResourceAsync();
        ///     
        ///     Console.WriteLine($"Received status {response.StatusCode}");
        ///     Console.WriteLine($"Received a resource of type {resource.Value?.GetType()}");
        ///     </code>
        /// </example>
        [DebuggerStepThrough]
        public async Task<(ApiResponse<#= TDeclaration #> Response, Variant<#= TDeclaration #> Resource)> FetchAsync(
            HttpCompletionOption completionOption = HttpCompletionOption.ResponseContentRead,
            CancellationToken cancellationToken = default)
        {
            var response = await FetchResponseAsync(completionOption, cancellationToken).ConfigureAwait(false);
            var resource = await response.DeserializeResourceAsync(cancellationToken).ConfigureAwait(false);
            return (response, resource);
        }

        /// <summary>
        ///     Sends the request, deserializes the HTTP content of the resulting HTTP response and
        ///     then returns this deserialized resource.
        /// </summary>
        /// <param name="completionOption">
        ///     Defines when the operation should complete (as soon as a response is
        ///     available or after reading the whole response content).
        /// </param>
        /// <param name="cancellationToken">
        ///     A cancellation token which can be used to cancel the operation.
        /// </param>
        /// <returns>
        ///     The deserialized resource represented through a <see cref="Variant<#= TXmlDeclaration #>"/>
        ///     which holds a value that matches the response type declared for the response's HTTP status code.
        ///     This variant is empty if the response's HTTP status code doesn't match any declared one.
        /// </returns>
        /// <exception cref="TaskCanceledException">
        ///     The operation was canceled via the <paramref name="cancellationToken"/>.
        /// </exception>
        /// <exception cref="HttpContentSerializationException">
        ///     There was a resource to deserialize, but the underlying <see cref="IHttpContentDeserializer"/>
        ///     threw an exception while deserializing the resource.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        ///     The <see cref="ApiRequestBase.HttpClientProvider"/> returned <see langword="null"/>.
        /// </exception>
        /// <remarks>
        ///     This method only returns the deserialized resource. Any other information about the
        ///     HTTP response, for example the returned HTTP status code, is lost.
        ///     If you are interested in any kind of information about the HTTP response, consider
        ///     using the <see cref="FetchAsync(HttpCompletionOption, CancellationToken)"/> method.
        ///     
        ///     Be aware that this method may throw an <see cref="HttpContentSerializationException"/>,
        ///     because it runs the code of an arbitrary <see cref="IHttpContentDeserializer"/>.
        ///     
        ///     This method uses the <see cref="ApiRequestBase.HttpClientProvider"/> function for retrieving an
        ///     <see cref="HttpClient"/> with which the request will be sent.
        /// </remarks>
        /// <example>
        ///     <code>
        ///     var resource = await response.FetchResourceAsync();
        ///     Console.WriteLine($"Received a resource of type {resource.Value?.GetType()}");
        ///     </code>
        /// </example>
        /// <seealso cref="FetchAsync(HttpCompletionOption, CancellationToken)"/>
        /// <seealso cref="FetchResponseAsync(HttpCompletionOption, CancellationToken)"/>
        [DebuggerStepThrough]
        public async Task<Variant<#= TDeclaration #>> FetchResourceAsync(
            HttpCompletionOption completionOption = HttpCompletionOption.ResponseContentRead,
            CancellationToken cancellationToken = default)
        {
            var response = await FetchResponseAsync(completionOption, cancellationToken).ConfigureAwait(false);
            try
            {
                return await response.DeserializeResourceAsync(cancellationToken).ConfigureAwait(false);
            }
            finally
            {
                // Since the user can never access this response, we must take care of this task.
                response.HttpResponseMessage.Dispose();
            }
        }
<#      } #>

    }
<#  } #>

}
