<#
    // Recommendation:
    // Don't edit this file in Visual Studio. Download VS Code and this extension:
    // https://marketplace.visualstudio.com/items?itemName=zbecknell.t4-support
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
const int MinParametersToGenerate = 0;
const int MaxParametersToGenerate = 8;

// Generates the string for a type parameter, e.g. "T1" or "T2".
// Empty string for 0, i.e. no type parameter.
string GetTParam(int index, string format = null) =>
	index == 0 ? "" : string.Format(format ?? "T{0}", index);

// Generates a list of type parameters until the index, e.g. ["T1", "T2", "T3"].
// Empty list for 0, i.e. no type parameter.
string[] GetTParamList(int to, string format = null) =>
	Enumerable
		.Range(1, to)
		.Select(i => GetTParam(i, format))
		.Where(s => !string.IsNullOrEmpty(s))
		.ToArray();

// Generates a string representing a list of type parameters until the index, e.g. "T1, T2, T3".
// Empty string for 0, i.e. no type parameter.
string GetTParamListString(int to, string format = null) =>
	string.Join(", ", GetTParamList(to, format));

// Generates a type parameter declaration of parameters until the index, e.g. "<T1, T2, T3>".
// Empty string for 0, i.e. no type parameter.
string GetTParamDeclaration(int to, string format = null) =>
	to == 0 ? "" : $"<{GetTParamListString(to, format)}>";

// Are type parameters generated for this index?
bool HasTypeParameter(int index) =>
	index != 0;
#>
// <auto-generated>
//   This code has been auto-generated by the associated .tt file.
//   Any changes made to in this file will be lost when the file is regenerated.
// </auto-generated>

#nullable enable

namespace ReqRest.Tests
{
    using System;
    using System.Collections.Generic;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;
    using Moq;
    using ReqRest.Http;
    using ReqRest.Serializers;
    using ReqRest.Tests.Sdk.Mocks;
    using ReqRest.Tests.Sdk.Models;
    using ReqRest.Tests.Sdk.TestBases;
    using Xunit;
<#  for (var i = MinParametersToGenerate; i <= MaxParametersToGenerate; i++) {
        var T = GetTParam(i, "Dto{0}");
        var TList = GetTParamList(i, "Dto{0}");
        var TListString = GetTParamListString(i, "Dto{0}");
        var TDeclaration = GetTParamDeclaration(i, "Dto{0}");
        var TNext = GetTParam(i + 1, "Dto{0}");
        var TNextDeclaration = GetTParamDeclaration(i + 1, "Dto{0}");
        var TPreviousDeclaration = i > 0 ? GetTParamDeclaration(i - 1, "Dto{0}") : "";
        var TestClassName = $"ApiResponse{(i == 0 ? "" : $"T{i}")}Tests";
        var hasTParam = HasTypeParameter(i);
        var isFirstT = i == MinParametersToGenerate;
        var isLastT = i == MaxParametersToGenerate;
        
        string Upgrade(string newParam) =>
            string.IsNullOrEmpty(TListString)
                ? newParam 
                : $"{TListString}, {newParam}";
        #>

    public abstract class <#= TestClassName #> : TestBase<ApiResponse<#= TDeclaration #>>
    {

        protected override ApiResponse<#= TDeclaration #> CreateService()
        {
            return CreateService(null, null);
        }

        protected ApiResponse<#= TDeclaration #> CreateService(
            HttpResponseMessage? httpResponseMessage, IEnumerable<ResponseTypeDescriptor>? possibleResponseTypes)
        {
            return new ApiResponse<#= TDeclaration #>(httpResponseMessage, possibleResponseTypes);
        }

        public class ConstructorTests : <#= TestClassName #>
        {
        
            [Fact]
            public void Uses_Specified_HttpResponseMessage()
            {
                var msg = new HttpResponseMessage();
                var service = CreateService(msg, null);
                Assert.Same(msg, service.HttpResponseMessage);
            }

            [Fact]
            public void Uses_Specified_PossibleResponseTypes()
            {
                var descriptors = new[]
                {
                    new ResponseTypeDescriptor(typeof(int), new StatusCodeRange[] { 200 }, () => null!),
                };
                var service = CreateService(null, descriptors);
                Assert.Equal(descriptors, service.PossibleResponseTypes);
            }

        }

        <# if (!isFirstT) { #>

        public class DeserializeResourceAsyncTests : <#= TestClassName #>
        {
            
            // The tests should cover that a certain DTO gets returned for a certain status code range.
            // It doesn't matter which status codes are used, but they should be different.
            protected const int UndefinedStatusCode = 404;
            protected const int Dto1StatusCode = 201;
            protected const int Dto2StatusCode = 202;
            protected const int Dto3StatusCode = 203;
            protected const int Dto4StatusCode = 204;
            protected const int Dto5StatusCode = 205;
            protected const int Dto6StatusCode = 206;
            protected const int Dto7StatusCode = 207;
            protected const int Dto8StatusCode = 208;

            protected ApiResponse<#= TDeclaration #> CreateServiceForDeserializationTests(
                int responseStatusCode, Func<IHttpContentDeserializer>? responseDeserializerFactory)
            {
                responseDeserializerFactory ??= () => 
                {
                    var mock = new Mock<IHttpContentDeserializer>();
                    mock.Setup(x => x.DeserializeAsync(It.IsAny<HttpContent>(), It.IsAny<Type>(), It.IsAny<CancellationToken>()))
                        .ReturnsAsync((HttpContent httpContent, Type type, CancellationToken ct) => Dummy.For(type));
                    return mock.Object;
                };

                var responseTypes = new List<ResponseTypeDescriptor>()
                {
                    new ResponseTypeDescriptor(typeof(Dto1), new StatusCodeRange[] { Dto1StatusCode }, responseDeserializerFactory),
                    new ResponseTypeDescriptor(typeof(Dto2), new StatusCodeRange[] { Dto2StatusCode }, responseDeserializerFactory),
                    new ResponseTypeDescriptor(typeof(Dto3), new StatusCodeRange[] { Dto3StatusCode }, responseDeserializerFactory),
                    new ResponseTypeDescriptor(typeof(Dto4), new StatusCodeRange[] { Dto4StatusCode }, responseDeserializerFactory),
                    new ResponseTypeDescriptor(typeof(Dto5), new StatusCodeRange[] { Dto5StatusCode }, responseDeserializerFactory),
                    new ResponseTypeDescriptor(typeof(Dto6), new StatusCodeRange[] { Dto6StatusCode }, responseDeserializerFactory),
                    new ResponseTypeDescriptor(typeof(Dto7), new StatusCodeRange[] { Dto7StatusCode }, responseDeserializerFactory),
                    new ResponseTypeDescriptor(typeof(Dto8), new StatusCodeRange[] { Dto8StatusCode }, responseDeserializerFactory),
                };
                var httpResponseMessage = new HttpResponseMessage()
                {
                    StatusCode = (HttpStatusCode)responseStatusCode,
                    Content = new ByteArrayContent(Array.Empty<byte>()),
                };

                return CreateService(httpResponseMessage, responseTypes);
            }
        
            [Fact]
            public async Task Throws_InvalidOperationException_If_SerializerFactory_Returns_Null()
            {
                var service = CreateServiceForDeserializationTests(
                    Dto1StatusCode,
                    responseDeserializerFactory: () => null!
                );
                await Assert.ThrowsAsync<InvalidOperationException>(async () => await service.DeserializeResourceAsync());
            }

            [Fact]
            public async Task Throws_HttpContentSerializationException_If_Serializer_Throws()
            {
                var mock = new Mock<IHttpContentDeserializer>();
                mock.Setup(x => x.DeserializeAsync(It.IsAny<HttpContent>(), It.IsAny<Type>(), It.IsAny<CancellationToken>()))
                    .ThrowsAsync(new Exception());

                var service = CreateServiceForDeserializationTests(
                    Dto1StatusCode,
                    responseDeserializerFactory: () => mock.Object
                );

                await Assert.ThrowsAsync<HttpContentSerializationException>(async () => await service.DeserializeResourceAsync());
            }

            [Fact]
            public async Task Returns_Empty_Variant_For_Undefined_Status_Code()
            {
                var service = CreateServiceForDeserializationTests(UndefinedStatusCode, null);
                var resource = await service.DeserializeResourceAsync();
                Assert.True(resource.IsEmpty);
            }

            <# for (var j = 1; j <= i; j++) { #>

            [Fact]
            public async Task Returns_Dto<#= j #>_For_Associated_Status_Code()
            {
                var service = CreateServiceForDeserializationTests(Dto<#= j #>StatusCode, null);
                var resource = await service.DeserializeResourceAsync();
                Assert.IsType<Dto<#= j #>>(resource.Value);
            }

            <# } #>
            
        }

        <# } #>

    }
    <# } #>

}

#nullable restore
